---
// Styles
import "@styles/objects/_word.scss";
import "@styles/components/_single-word.scss";
import "astro-breadcrumbs/breadcrumbs.scss";

// Imports
import { getAllWords } from "@services/api";
import Layout from "@layouts/Layout.astro";
import ArrowLeft from "~icons/lucide/arrow-left";
import Info from "~icons/lucide/info";
import ExternalLink from "~icons/lucide/external-link";
import Crown from "~icons/lucide/crown";
import ChevronRight from "~icons/lucide/chevron-right";
import WordExamples from "@components/word/WordExamples.vue";
import IsWordOfTheDay from "@components/word/IsWordOfTheDay.vue";
import RelatedWords from "@components/RelatedWords.vue";
import RandomWordButton from "@components/RandomWordButton.vue";
import NavigateBack from "@components/NavigateBack.vue";
import { routeToWord, seoData } from "@utils/helpers";
import { Breadcrumbs } from "astro-breadcrumbs";
import { Picture } from "astro:assets";
import { fetchWikimediaAPI } from "@services/wikimediaApi.ts";

// Types
import type { InferGetStaticParamsType, InferGetStaticPropsType } from "astro";
import type { BerlinerWord } from "@ts_types/generated/graphql";

export const getStaticPaths = async () => {
  const allWords = await getAllWords();

  return allWords.map(({ node }) => {
    return {
      params: {
        wordSlug: node.slug,
      },
      props: {
        word: node as BerlinerWord,
        allWords: allWords.map((word) => word.node),
      },
    };
  });
};

type Params = InferGetStaticParamsType<typeof getStaticPaths>;
type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { wordSlug } = Astro.params as Params;
const { word, allWords } = Astro.props as Props;

const wordProps: BerlinerWord["wordProperties"] = word.wordProperties;

const formattedDate = (date: string, locale = "de-DE") => {
  if (!date) return;
  const dateToFormat = new Date(date);

  return dateToFormat.toLocaleString(locale, { year: "numeric", month: "long", day: "numeric" });
};

const alternativeWords = wordProps?.alternativeWords?.map((word, index) => {
  return (
    word?.alternativeWord +
    (wordProps?.alternativeWords && index !== wordProps?.alternativeWords?.length - 1 ? ", " : "")
  );
});

/**
 * TODO: Fix RelatedWords (allways returns null)
 */
// console.log(wordProps?.relatedWords?.nodes);

/**
 * Create a list of all wikimedia files
 */
const createWikimediaFileList = async () => {
  if (!wordProps?.wikimediaFiles) return;

  let files = [];
  for (const file of wordProps?.wikimediaFiles!) {
    const img = await fetchWikimediaAPI(file.wikimediaFile);
    files.push(img);
  }
  return files;
};

const wikimediaFiles = await createWikimediaFileList();
console.log(wikimediaFiles);
---

<Layout content={seoData(word)} contentClasses="o-word">
  <Breadcrumbs indexText="start">
    <ChevronRight slot="separator" width="20" height="20" />
  </Breadcrumbs>

  <article class="c-single-word">
    <header class="c-single-word__header">
      <IsWordOfTheDay
        wordId={word.berlinerWordId}
        word={wordProps?.berlinerisch}
        client:only="vue"
      />

      <h1 class="c-single-word__word">
        {wordProps?.berlinerisch}

        {
          wordProps?.article && (
            <span class="c-single-word__word-article">, {wordProps.article}</span>
          )
        }
      </h1>
    </header>

    {
      wordProps?.wikimediaFiles && wikimediaFiles && (
        <div class="c-single-word__image-wrapper">
          {wikimediaFiles?.map((file) => {
            return (
              <Picture
                src={file.preferred.url}
                alt={wordProps?.berlinerisch!}
                width={file.preferred.width}
                height={file.preferred.height}
                formats={["avif", "webp"]}
                widths={[327, 455, 637]}
                class="c-single-word__image"
              />
            );
          })}
        </div>
      )
    }

    {
      wordProps?.alternativeWords && (
        <div class="c-single-word__alternative-words-wrapper">
          <h2>Selbe Bedeutung wie:</h2>
          <p class="c-single-word__alternative-word">{alternativeWords}</p>
        </div>
      )
    }

    {
      wordProps?.learnMore && (
        <div class="c-single-word__learn-more-wrapper">
          <Info />{" "}
          <a href={wordProps?.learnMore} target="_blank" class="c-single-word__learn-more-link">
            Erfahre mehr Ã¼ber dieses Wort{" "}
            <span class="c-single-word__learn-more-link-icon">
              <ExternalLink width="10" height="10" />
            </span>
          </a>
        </div>
      )
    }

    {
      word?.berlinerischWordTypes && word?.berlinerischWordTypes.nodes.length > 0 && (
        <div class="c-single-word__word-type-wrapper">
          <h2 class="c-single-word__sub-headline">Wortart:</h2>
          <p class="c-single-word__word-type">{word?.berlinerischWordTypes.nodes[0].name}</p>
        </div>
      )
    }

    <div class="c-single-word__translation-wrapper">
      {wordProps?.translations && <h2 class="c-single-word__sub-headline">Bedeutung:</h2>}

      <ul class="c-single-word__translation">
        {
          wordProps?.translations?.map((translation) => {
            return <li class="c-single-word__translation-item">{translation?.translation}</li>;
          })
        }
      </ul>
    </div>

    <div class="c-single-word__examples-wrapper">
      {
        wordProps?.examples && (
          <>
            <h2 class="c-single-word__sub-headline">Beispiele:</h2>
            <WordExamples examples={wordProps.examples} rootBemClass="c-single-word" />
          </>
        )
      }
    </div>

    {
      wordProps?.relatedWords?.nodes && (
        <div class="c-single-word__related-words-wrapper">
          <h3>Verwandte Worte:</h3>
          <ul class="c-single-word__related-words-list">
            {wordProps.relatedWords.nodes.map((word): BerlinerWord[] => {
              return (
                <li class="c-single-word__related-word">
                  <a href={routeToWord(word?.slug!)} class="c-single-word__related-word-link">
                    {word?.wordProperties?.berlinerisch}
                  </a>
                </li>
              );
            })}
          </ul>
        </div>
      )
    }

    <footer class="c-single-word__footer">
      <p class="c-single-word__created">
        Wort erstellt am: {formattedDate(word.dateGmt!)}
      </p>
      <p class="c-single-word__modified">
        Bearbeitet am: {formattedDate(word.modifiedGmt!)}
      </p>
    </footer>
  </article>

  <RelatedWords words={allWords}>
    <RandomWordButton words={allWords} class:list="c-related-words__word is-random" />
  </RelatedWords>
</Layout>
