---
// Styles
import "@styles/objects/_word.scss";
import "@styles/components/_single-word.scss";
import "@styles/plugins/astro-breadcrumbs.scss";

// Imports
import { getAllWords } from "@services/api.ts";
import Layout from "@layouts/Layout.astro";
import ExternalLink from "~icons/lucide/external-link";
import ChevronRight from "~icons/lucide/chevron-right";
// import WordExamples from "@components/word/WordExamples.vue";
import WordExamples from "@components/word/WordExamples.astro";
import IsWordOfTheDay from "@components/word/IsWordOfTheDay.vue";
import RelatedWords from "@components/RelatedWords.vue";
import RandomWordButton from "@components/RandomWordButton.vue";
import { routeToWord, seoData } from "@utils/helpers.ts";
import { Breadcrumbs } from "astro-breadcrumbs";
import { fetchWikimediaAPI } from "@services/wikimediaApi.ts";
import WordOptionDropdown from "@components/word/WordOptionDropdown.vue";
import ImageGallery from "@components/ImageGallery.astro";
import ToolTip from "@components/ToolTip.vue";
import BadgeTag from "@components/BadgeTag.vue";
import AudioPlayerList from "@components/AudioPlayerList.vue";
import Hypher from "hypher";
import german from "hyphenation.de";
import nlp from "compromise";
import de from "de-compromise";

// Types
import type { InferGetStaticParamsType, InferGetStaticPropsType } from "astro";
import type { BerlinerWord } from "@ts_types/generated/graphql.ts";

export const getStaticPaths = async () => {
  const allWords = await getAllWords();

  return allWords.map(({ node }) => {
    return {
      params: {
        wordSlug: node.slug,
      },
      props: {
        word: node as BerlinerWord,
        allWords: allWords.map((word) => word.node),
      },
    };
  });
};

type Params = InferGetStaticParamsType<typeof getStaticPaths>;
type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { wordSlug } = Astro.params as Params;
const { word, allWords } = Astro.props as Props;

const wordProps: BerlinerWord["wordProperties"] = word.wordProperties;

const formattedDate = (date: string, locale = "de-DE") => {
  if (!date) return;
  const dateToFormat = new Date(date);

  return dateToFormat.toLocaleString(locale, { year: "numeric", month: "long", day: "numeric" });
};

const alternativeWords = wordProps?.alternativeWords?.map((word, index) => {
  return (
    word?.alternativeWord +
    (wordProps?.alternativeWords && index !== wordProps?.alternativeWords?.length - 1 ? ", " : "")
  );
});

/**
 * TODO: Fix RelatedWords (allways returns null)
 */
// console.log(wordProps?.relatedWords?.nodes);

/**
 * Create a list of all wikimedia files
 */
const createWikimediaFileList = async () => {
  if (!wordProps?.wikimediaFiles) return;

  let files = [];
  for (const file of wordProps?.wikimediaFiles!) {
    const img = await fetchWikimediaAPI(file?.wikimediaFile!);
    files.push({ image: img, description: file?.description, caption: file?.caption });
  }
  return files;
};

const wikimediaFiles = await createWikimediaFileList();
// console.log(wikimediaFiles);

let galleryWidths = [316, 457, 658, 429, 525];
let gallerySizes =
  "(max-width: 80rem) 525px, (max-width: 64rem) 429px, (max-width: 48rem) 658px, (max-width: 35.49rem) 457px, (max-width: 26.6rem) 316px";
const lightboxWidths = [425, 567, 768, 896];
const lightboxSizes =
  "(max-width: 26.6rem) 425px, (max-width: 35.49rem) 567px, (max-width: 48rem) 768px, (max-width: 64rem) 896px";

if (wordProps?.images && wordProps?.images?.nodes.length > 1) {
  galleryWidths = [503, 435, 307];
  gallerySizes =
    "(max-width: 70rem) 503px, (max-width: 64rem) 435px, (max-width: 48rem) 307px, (max-width: 35.5rem) 435px, (max-width: 27.2rem) 307px";
}

const hypher = new Hypher(german);

console.log(hypher.hyphenate("Knorke"));

const coloredConsonantsAndVowels = (word: string) => {
  let html = "";

  for (let char of word) {
    if ("aeiouäöü".includes(char.toLowerCase())) {
      html += `<span class="is-vowel">${char}</span>`; // Vowels
    } else {
      html += `<span class="is-consonant">${char}</span>`; // Consonants
    }
  }

  return html;
};

const countLetters = (word: string) => {
  let vowelsCount = 0;
  let consonantsCount = 0;

  for (let char of word) {
    if ("aeiouäöü".includes(char.toLowerCase())) {
      vowelsCount++;
    } else if (char.match(/[a-zäöüß]/i)) {
      consonantsCount++;
    }
  }

  return {
    vowels: vowelsCount,
    consonants: consonantsCount,
  };
};

type TagTranslations = {
  [key: string]: string;
};

type WordTags = {
  [key: string]: string[];
};

nlp.extend(de);

const getWordType = (word: string): WordTags[] => {
  const doc = nlp(word);

  return doc.out("tags");
};

const translateNlpTags = (tags: WordTags[]): WordTags[] => {
  let tagTranslations: TagTranslations = {
    Noun: "Nomen",
    Singular: "Einzahl",
    Plural: "Mehrzahl",
    Verb: "Verb",
    Adjective: "Adjektiv",
    ProperNoun: "Eigenname",
    Pronoun: "Pronomen",
    Determiner: "Artikel",
    Adverb: "Adverb",
    Conjunction: "Konjunktion",
    Preposition: "Präposition",
    Interjection: "Interjektion",
    Auxiliary: "Hilfsverb",
    Negative: "Negation",
    Particle: "Partikel",
    Possessive: "Possessivpronomen",
    QuestionWord: "Fragepronomen",
    Date: "Datum",
    Time: "Zeit",
    Value: "Wert",
    Phone: "Telefon",
    Email: "E-Mail",
    URL: "URL",
    Hashtag: "Hashtag",
    Emoji: "Emoji",
    Emoticon: "Emoticon",
    Acronym: "Akronym",
    Abbreviation: "Abkürzung",
    Honorific: "Anrede",
    Actor: "Schauspieler",
  };

  let translatedTags: WordTags[] = tags.map((tag: WordTags) => {
    let translatedTag: WordTags = {};
    for (let word in tag) {
      let englishTags = tag[word];
      let germanTags = englishTags.map((englishTag) => tagTranslations[englishTag] || englishTag);
      translatedTag[word] = germanTags;
    }
    return translatedTag;
  });

  return translatedTags;
};

const wordTags = translateNlpTags(getWordType(word.wordProperties?.berlinerisch!));
console.log(getWordType("Zahnklempner mit Zahnklempnerin"));

console.log(wordTags);
//
// let doc = nlp("ditt");

// let tags = doc.out("tags");

// console.log(tags);
---

<Layout content={seoData(word)} contentClasses="o-word">
  <Breadcrumbs indexText="start" truncated={true}>
    <ChevronRight slot="separator" width="20" height="20" />
  </Breadcrumbs>

  <IsWordOfTheDay
    wordId={word.berlinerWordId}
    word={wordProps?.berlinerisch}
    iconSize={50}
    tooltipPlacement="top"
    client:only="vue"
  />
  <article class="c-single-word" data-pagefind-body>
    <header class="c-single-word__header">
      <h1 class="c-single-word__word">
        {wordProps?.berlinerisch}

        {
          wordProps?.article && (
            <span class="c-single-word__word-article">, {wordProps.article}</span>
          )
        }
      </h1>
      {
        word.wordProperties?.berlinerischAudio && (
          <AudioPlayerList
            audio={word.wordProperties?.berlinerischAudio}
            isType="berlinerisch"
            client:only="vue"
          />
        )
      }

      {
        wordProps?.berolinismus && (
          <ToolTip client:only="vue">
            <BadgeTag> Berolinismus </BadgeTag>
            <Fragment slot="content">
              {word.wordProperties?.berlinerisch} gehört zu den Berlinismen.
              <br />
              <br />
              <strong>Berolinismus</strong>
              sind humorvolle Spitznamen und Eigenheiten, die bestimmte Orte und Gebäude in Berlin
              charakterisieren und das lokale Flair der Stadt prägen.
            </Fragment>
          </ToolTip>
        )
      }
      <WordOptionDropdown
        berlinerisch={word.wordProperties?.berlinerisch}
        slug={word.slug}
        client:only="vue"
      />
    </header>
    <main class="c-single-word__main">
      {
        wordProps?.alternativeWords && (
          <div class="c-single-word__alternative-words-wrapper">
            <h2>Selbe Bedeutung wie:</h2>
            <p class="c-single-word__alternative-word">{alternativeWords}</p>
          </div>
        )
      }

      {
        word?.berlinerischWordTypes && word?.berlinerischWordTypes.nodes.length > 0 && (
          <div class="c-single-word__word-type-wrapper">
            <h2 class="c-single-word__sub-headline">Wortart:</h2>
            <p class="c-single-word__word-type">{word?.berlinerischWordTypes.nodes[0].name}</p>
          </div>
        )
      }

      {
        wordProps?.translations && (
          <div class="c-single-word__translation-wrapper">
            <h2 class="c-single-word__sub-headline">Bedeutung:</h2>

            <ul class="c-single-word__translation">
              {wordProps?.translations?.map((translation) => {
                return <li class="c-single-word__translation-item">{translation?.translation}</li>;
              })}
            </ul>
          </div>
        )
      }

      {
        wordProps?.examples && (
          <div class="c-single-word__examples-wrapper">
            <h2 class="c-single-word__sub-headline">Beispiele:</h2>
            <WordExamples examples={wordProps.examples} rootBemClass="c-single-word" />
          </div>
        )
      }

      <div class="c-single-word__syllables">
        <h2>Silben und Silbentrennung</h2>

        <h3>Silbentrennung:</h3>
        <p>{hypher.hyphenate(word.wordProperties?.berlinerisch).join(" | ")}</p>

        <h3>Anzahl der Silben:</h3>
        <p>{hypher.hyphenate(word.wordProperties?.berlinerisch).length}</p>
      </div>
      <div class="c-single-word__consonants-vowels">
        <h2>Konsonanten und Vokale</h2>
        <div set:html={coloredConsonantsAndVowels(word.wordProperties?.berlinerisch!)} />

        <p>
          enhält {countLetters(word.wordProperties?.berlinerisch!).vowels}
          <span class="is-vowel">Vokale</span> und {
            countLetters(word.wordProperties?.berlinerisch!).consonants
          }
          <span class="is-consonat">Konsonanten</span>
        </p>
      </div>

      <div>
        <h2>Grammtik</h2>

        {
          wordTags.length > 0 &&
            Object.keys(wordTags[0]).map((key) => {
              return (
                <div>
                  <h3>{key}</h3>
                  {wordTags[0][key].length === 1 ? (
                    <p>{wordTags[0][key][0]}</p>
                  ) : (
                    <ul>
                      {wordTags[0][key].map((tag) => (
                        <li>{tag}</li>
                      ))}
                    </ul>
                  )}
                </div>
              );
            })
        }
      </div>

      {
        wordProps?.relatedWords?.nodes && wordProps?.relatedWords?.nodes.length > 0 && (
          <div class="c-single-word__related-words-wrapper">
            <h3>Verwandte Worte:</h3>
            <ul class="c-single-word__related-words-list">
              {wordProps.relatedWords.nodes.map((word): BerlinerWord[] => {
                return (
                  <li class="c-single-word__related-word">
                    <a href={routeToWord(word?.slug!)} class="c-single-word__related-word-link">
                      {word?.wordProperties?.berlinerisch}
                    </a>
                  </li>
                );
              })}
            </ul>
          </div>
        )
      }
    </main>

    {
      wordProps?.images && (
        <section class="c-single-word__gallery-wrap">
          <h2>Bilder:</h2>
          <ImageGallery
            images={wordProps?.images}
            widths={galleryWidths}
            sizes={gallerySizes}
            lightboxWidths={lightboxWidths}
            lightboxSizes={lightboxSizes}
            loading="eager"
          />
        </section>
      )
    }

    {
      wordProps?.learnMore && (
        <a
          href={wordProps?.learnMore}
          target="_blank"
          class="c-single-word__learn-more-link"
          title="mehr zu diesen Wort auf Wikipedia"
        >
          Erfahre mehr über dieses Wort
          <span class="c-single-word__learn-more-link-icon">
            <ExternalLink width="10" height="10" />
          </span>
        </a>
      )
    }

    <footer class="c-single-word__footer">
      <p class="c-single-word__created">
        Wort erstellt am: {formattedDate(word.dateGmt!)}
      </p>
      <p class="c-single-word__modified">
        Bearbeitet am: {formattedDate(word.modifiedGmt!)}
      </p>
    </footer>
  </article>

  <RelatedWords words={allWords}>
    <RandomWordButton words={allWords} class:list="c-related-words__word is-random" />
  </RelatedWords>
</Layout>
